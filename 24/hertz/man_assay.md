I like to think of electronic structure theory in terms of a disabled person, like myself, making a smoothie.

We first need a blender, but this sounds so obvious that you wonder why I even mention it. In order to run an electronic structure theory, you need to be able to manipulate code efficiently, which is classically done by typing. I had a stroke resulting in a fine motor impairment. Therefore, I learned to code by voice. I also use ChatGPT in unconventional ways. I have learned to do prompt engineering, where one designs an instruction for interpretation by a generative AI model. The initial idea was just to tell ChatGPT to "act like a proofreader" and fix the misrecognitions in my dictated text (of which there are many due to my speech impairment). However, I went further by also giving ChatGPT an example of my raw dictation with its many misrecognitions and then a clean version of what I had meant to say. For example, I might give ChatGPT an example of my bad dictation recognition: "The quick front dogs jumps over the late dog," whereas it knows that I had meant to say "The quick brown fox jumps over the lazy dog." ChatGPT then uses this contextual information to anticipate what typos I might give it in the actual text that I want it to correct. In reality, I use the longer example of the “rainbow passage” for this purpose. I knew of it from speech therapy evaluations, where the therapists use it to determine what needs to be worked on, since it concisely encompasses all common sounds of the English language. Armed with this context, ChatGPT is able to output a more accurate rendition of what I had meant to say. How this all works is best explained by the GIFs in my exhibits.

The next thing we need are some ingredients. To figure out what to buy, we might ask Google for some recipes. To figure out what code to write, I talk with my advisor. But I can't take notes during the meeting. So I record everything over Zoom and then return to watch it later. I also use ChatGPT to reason through code that I want to understand better. Additionally, I use Perplexity AI. People have likened it to if Google and Wikipedia had a baby. It does a live web search to produce citations in its responses so you know it is not "hallucinating" like ChatGPT.

The first approach might be to make the smoothies on a daily basis. But it takes me a while to set everything up, and even longer to wash up afterward. A quick search on Google shows that you can leave something in the freezer for 3 months, and then when you defrost it, it is as good as fresh. In electronic structure theory, you can use Python to write code that will give you the precise number you want, such as the band gap of a semiconductor. But Python has a lot of overhead, meaning that it hides many of the elements of what the machine is doing for the benefit of an easy user experience, but at the cost of sacrificing efficiency, i.e., it might take eons for this computation to run. The alternative is coding in C++, which requires much more expertise but allows you to control what the machine does during runtime much better. As a relatively new C++ programmer, learning the specific syntax of this language can be quite difficult, but GitHub Copilot is an apt translator.

I like to add peanut butter to my smoothies, but I have found that at its room temperature, the liquid form sticks to the side of the blender, making for difficult cleanup. After asking Google Gemini, the AI chatbot built into my Android smartphone, I learned that this can be alleviated by putting the peanut butter into ice cube trays, freezing it, and then simply taking out a cube when you want to make a smoothie. This is analogous to the parallelization that can be achieved with graphical processing units (GPUs) in electronic structure theory. With the anticipation that we will be making smoothies with peanut butter in the future, we can freeze some peanut butter in advance, in order to efficiently carry out the blending of the smoothie when it happens. Suppose we know that when the computer reaches a certain point in the program, it will need to perform similar loops, which are computationally expensive. So when it hits this point of the forum, we can delegate one loop to seperate entities to run the same thing in parallel, instead of waiting for the first loop to finish before starting the second. 